import java_cup.runtime.*;
import java.util.*;

init with {:
 
	objHash =   new HashMap();
	htmlOutput = new StringBuffer();

:};

parser code {:
   public static HashMap objHash;
   public static StringBuffer htmlOutput;
    
   public void report_error(String message, Object info) {
  
    StringBuffer m = new StringBuffer("Error ");

    if (info instanceof java_cup.runtime.Symbol){
        java_cup.runtime.Symbol s = (java_cup.runtime.Symbol)info;
        m.append( "("+s.toString()+")" );
    	m.append( " Error at line "+s.left);
    	m.append( " column "+s.right);
    	m.append( " with symbol "+s.sym);
    }
    m.append(" : "+message);
   
    System.err.println(m);
  } 
   
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }

    
    
    
:};


terminal STAR, STARDOUBLE,/*EQUAL,*/SPACE,NEWLINE,UNDERSCORE,UNDERSCOREDOUBLE;
terminal String STRING/*, URL*/;
terminal Character LITCHAR;

//non terminal symbols
non terminal file,emphasized,textString,spaceList,newlineList,newlineSingle/*,newlineDouble*/,bold,paragraph,parsedText,conjugation;

start with file;

file ::= paragraph {:
	System.out.printf("Grammar ok\n");
	System.out.printf("The output is\n\n%s\n",parser.htmlOutput);	
:};

newlineSingle ::= NEWLINE {: RESULT = new String("\n"); :};

                        // Riconosce una lista di accapo(/n).
newlineList::=          newlineSingle:nls NEWLINE {: RESULT= new String(nls+"\n"); :}
        |               newlineList:nll NEWLINE {: RESULT= new String(nll+"\n");:} ;
	
                        
spaceList ::=           SPACE {: RESULT= new String(" "); :}
        |               spaceList:sl SPACE {: RESULT= new String(sl+" ");   :} ;			

//Strighe usate nell'italico e nel bold        
textString::= 
			STRING:s {: RESULT=s; :}
	| 		textString:s1 LITCHAR:l STRING:s2 {: RESULT=(s1+l.toString()+s2); :} 
	|		textString:s1 newlineSingle:nls STRING:s2 {: RESULT=s1+(String)nls+s2; :}
                         //Considero come test string anche le stringhe del tipo "pip pipo"
        |               textString:s1 spaceList:sl STRING:s2 {: RESULT=s1+(String)sl+s2; :}	
	;



                        // Riconosce gli italici
emphasized ::=  
			STAR textString:s STAR {: System.out.printf("Rule emphasized found [%s]\n",s);
			RESULT= new String("<em>"+s+"</em>");
			:}


	|		UNDERSCORE textString:s UNDERSCORE {: System.out.printf("Rule bold found [%s]\n",s);
			RESULT= new String("<em>"+s+"</em>");  
			:};
                      
                        
                      //riconosce i bold 
 bold ::=             STARDOUBLE textString:s STARDOUBLE {: System.out.printf("Rule bold found [%s]\n",s);
                      RESULT= new String("<strong>"+s+"</strong>");
                      :}
                      
      |               UNDERSCOREDOUBLE textString:s UNDERSCOREDOUBLE{: System.out.printf("Rule bold found [%s]\n",s);
                      RESULT= new String("<strong>"+s+"</strong>");
                      :};
                     
                
                      //Denisco l'annidamento tra un italico e un bold
conjugation::=        STARDOUBLE STAR textString:s STARDOUBLE STAR {: System.out.printf("Rule conjugation found [%s]\n",s);
                      RESULT= new String("<strong><em>"+s+"</em></strong>");:}
                    
      |               UNDERSCOREDOUBLE STAR textString:s UNDERSCOREDOUBLE STAR {: System.out.printf("Rule conjugation found [%s]\n",s);
                      RESULT= new String("<strong><em>"+s+"</em></strong>");:}

      |               STARDOUBLE UNDERSCORE textString:s STARDOUBLE UNDERSCORE {: System.out.printf("Rule conjugation found [%s]\n",s);
                      RESULT= new String("<strong><em>"+s+"</em></strong>");:}
                    
      |               UNDERSCOREDOUBLE UNDERSCORE textString:s UNDERSCOREDOUBLE UNDERSCORE {: System.out.printf("Rule conjugation found [%s]\n",s);
                      RESULT= new String("<strong><em>"+s+"</em></strong>");:}   
      ;                    
			
parsedText ::= 
                STRING:s {: RESULT=(String)s; :}
	|       emphasized:em {: RESULT=(String)em; :}
	|	bold:bd {: RESULT=(String)bd; :} 
                //Sequenza di piu elementi
        |       parsedText:pt spaceList:sl emphasized:em {: RESULT=pt+(String)sl+(String)em; :}
        |       parsedText:pt spaceList:sl bold:bl {: RESULT=pt+(String)sl+(String)bl; :}
        |       parsedText:pt spaceList:sl STRING:s {: RESULT=pt+(String)sl+(String)s; :}
        ;
        
paragraph ::= 
                //Inserisco il paragrafo in qualsiasi sequenza di stili(bold,italico,stringa) separati da uno space
                parsedText:pt {: parser.htmlOutput.append("<p>"+(String)pt+"</p>");:}  
        |       conjugation:c {: parser.htmlOutput.append("<p>"+(String)c+"</p>");:} 
                //Riconosce il paragrafo anche se seguito da spazi. NB. gli spazi compaiono nell'output
        |       parsedText:pt spaceList:sl {: parser.htmlOutput.append("<p>"+(String)pt+(String)sl+"</p>");:}
                //Riconosce il paragrafo anche se seguito da un invio(/n) NB. l'accapo non compare nell'ouput
        |       parsedText:pt newlineSingle:nsl {: parser.htmlOutput.append("<p>"+(String)pt+"</p>");:}
                //Riconosce il paragrafo anche se seguito da piu invii(/n/n/n) NB. l'accapo non compare nell'ouput
        |       parsedText:pt newlineList:nll {: parser.htmlOutput.append("<p>"+(String)pt+"</p>");:}
                //Riconosce il paragrafo seguito da uno spazio e da accapo
        |        parsedText:pt spaceList:sl newlineSingle:nsl {: parser.htmlOutput.append("<p>"+(String)pt+(String)sl+"</p>");:}
                //Riconosce il paragrafo seguito da spazi e da accapo
        |        parsedText:pt spaceList:sl  newlineList:nll {: parser.htmlOutput.append("<p>"+(String)pt+(String)sl+"</p>");:}
        
        ;
        
        
        
        
        